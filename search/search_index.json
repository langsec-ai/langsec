{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LangSec","text":""},{"location":"#langsec-a-security-framework-for-text-to-sql","title":"LangSec: A Security Framework for Text-to-SQL","text":"<p>A security framework for validating and securing LLM-generated SQL queries. LangSec helps prevent SQL injection, unauthorized access, and other security vulnerabilities when working with language models that generate SQL.</p> <p></p> <p>Demonstration of making a malicious query using Vanna. LangSec helps prevent such attacks by validating generated queries against a security schema.</p> <p></p>"},{"location":"installation/","title":"Installation","text":"<p>Installing the package is as simple as running the following command:</p> <pre><code>pip install langsec\n</code></pre>"},{"location":"quick-start/","title":"LangSec: SQL Query Security Framework","text":"<p>LangSec is a robust Python framework designed to enforce security policies on SQL queries. It's particularly valuable when working with LLMs (Large Language Models) or handling user-generated queries where query validation and security enforcement are critical.</p>"},{"location":"quick-start/#core-concepts","title":"Core Concepts","text":""},{"location":"quick-start/#security-guard","title":"Security Guard","text":"<p>The <code>SQLSecurityGuard</code> is the main entry point for query validation:</p> <pre><code>from langsec import SQLSecurityGuard\nfrom langsec.schema.security_schema import SecuritySchema\nfrom langsec.config import LangSecConfig\n\n# Basic initialization\nguard = SQLSecurityGuard(schema=schema)\n\n# With custom configuration\nconfig = LangSecConfig(\n    log_queries=True,\n    log_path=\"/path/to/logs/queries.log\",\n    raise_on_violation=True\n)\nguard = SQLSecurityGuard(schema=schema, config=config)\n</code></pre>"},{"location":"quick-start/#configuration-options","title":"Configuration Options","text":"<p>The <code>LangSecConfig</code> class provides several options to customize LangSec's behavior:</p> <pre><code>class LangSecConfig:\n    log_queries: bool = False        # Enable/disable query logging\n    log_path: Optional[str] = None   # Path for log file\n    raise_on_violation: bool = True  # Raise exceptions vs return False\n</code></pre>"},{"location":"quick-start/#security-schema-structure","title":"Security Schema Structure","text":"<p>The security schema is the cornerstone of LangSec's security model. It defines what operations are allowed on your database at multiple levels:</p>"},{"location":"quick-start/#1-column-level-security","title":"1. Column Level Security","text":"<pre><code>from langsec.schema.sql.enums import Access, AggregationType\n\n# Basic read-only column\ncolumn = ColumnSchema(\n    access=Access.READ,\n    allowed_operations={\"SELECT\"}\n)\n\n# Column with aggregation permissions\nmetrics_column = ColumnSchema(\n    access=Access.READ,\n    allowed_operations={\"SELECT\"},\n    allowed_aggregations={\n        AggregationType.SUM,\n        AggregationType.AVG,\n        AggregationType.COUNT\n    }\n)\n\n# Write-only audit column\naudit_column = ColumnSchema(\n    access=Access.WRITE,\n    allowed_operations={\"INSERT\"}\n)\n</code></pre>"},{"location":"quick-start/#2-table-level-security","title":"2. Table Level Security","text":"<pre><code>from langsec.schema.sql.enums import JoinType\n\ntable = TableSchema(\n    columns={\n        \"id\": ColumnSchema(access=Access.READ),\n        \"username\": ColumnSchema(access=Access.READ),\n        \"email\": ColumnSchema(access=Access.DENIED)\n    },\n    allowed_joins={\n        \"orders\": {JoinType.INNER, JoinType.LEFT},\n        \"products\": {JoinType.INNER}\n    },\n    default_allowed_join=None  # Default join policy for unlisted tables\n)\n</code></pre>"},{"location":"quick-start/#3-database-level-security","title":"3. Database Level Security","text":"<pre><code>schema = SecuritySchema(\n    tables={\n        \"users\": users_table_schema,\n        \"orders\": orders_table_schema,\n        \"products\": products_table_schema\n    },\n    max_joins=2,                    # Maximum number of joins allowed\n    allow_subqueries=True,          # Enable/disable subqueries\n    max_query_length=1000,          # Maximum query length\n    sql_injection_protection=True,   # Enable basic SQL injection protection\n    forbidden_keywords={            # SQL keywords to block\n        \"DROP\", \"DELETE\", \"TRUNCATE\",\n        \"ALTER\", \"GRANT\", \"REVOKE\",\n        \"EXECUTE\", \"EXEC\",\n        \"SYSADMIN\", \"DBADMIN\"\n    },\n    # Default schemas for tables/columns not explicitly defined\n    default_table_security_schema=TableSchema(...),\n    default_column_security_schema=ColumnSchema(...)\n)\n</code></pre>"},{"location":"quick-start/#query-validation","title":"Query Validation","text":"<p>The validation process checks multiple aspects of the query:</p> <ol> <li>Access Control: Verifies that the query only accesses allowed tables and columns</li> <li>Join Validation: Ensures joins are allowed and don't exceed complexity limits</li> <li>Aggregation Control: Validates that aggregation functions are permitted</li> <li>Query Complexity: Checks query length and subquery usage</li> <li>SQL Injection Protection: Basic SQL injection prevention</li> </ol> <pre><code>try:\n    guard.validate_query(\"\"\"\n        SELECT \n            users.username,\n            SUM(orders.amount) as total_spent\n        FROM users\n        LEFT JOIN orders ON users.id = orders.user_id\n        WHERE users.created_at &gt; '2024-01-01'\n        GROUP BY users.username\n    \"\"\")\nexcept Exception as e:\n    print(f\"Query validation failed: {e}\")\n</code></pre>"},{"location":"quick-start/#access-control-patterns","title":"Access Control Patterns","text":""},{"location":"quick-start/#pattern-1-read-only-analytics","title":"Pattern 1: Read-Only Analytics","text":"<pre><code>analytics_schema = SecuritySchema(\n    tables={\n        \"users\": TableSchema(\n            columns={\n                \"id\": ColumnSchema(access=Access.READ),\n                \"signup_date\": ColumnSchema(access=Access.READ),\n                \"country\": ColumnSchema(access=Access.READ)\n            },\n            allowed_joins={\"orders\": {JoinType.LEFT, JoinType.INNER}}\n        ),\n        \"orders\": TableSchema(\n            columns={\n                \"user_id\": ColumnSchema(access=Access.READ),\n                \"amount\": ColumnSchema(\n                    access=Access.READ,\n                    allowed_aggregations={\n                        AggregationType.SUM,\n                        AggregationType.AVG,\n                        AggregationType.COUNT\n                    }\n                ),\n                \"order_date\": ColumnSchema(access=Access.READ)\n            }\n        )\n    },\n    max_joins=2,\n    allow_subqueries=True\n)\n</code></pre>"},{"location":"quick-start/#pattern-2-audit-logging-system","title":"Pattern 2: Audit Logging System","text":"<pre><code>audit_schema = SecuritySchema(\n    tables={\n        \"users\": TableSchema(\n            columns={\n                \"id\": ColumnSchema(access=Access.READ),\n                \"username\": ColumnSchema(access=Access.READ),\n                \"last_login\": ColumnSchema(\n                    access=Access.WRITE,\n                    allowed_operations={\"UPDATE\", \"SELECT\"}\n                )\n            }\n        ),\n        \"audit_log\": TableSchema(\n            columns={\n                \"user_id\": ColumnSchema(access=Access.WRITE),\n                \"action\": ColumnSchema(access=Access.WRITE),\n                \"timestamp\": ColumnSchema(access=Access.WRITE),\n                \"details\": ColumnSchema(access=Access.WRITE)\n            },\n            # No joins allowed on audit log\n            allowed_joins={},\n            default_allowed_join=None\n        )\n    },\n    # Strict settings for audit system\n    max_joins=0,\n    allow_subqueries=False,\n    sql_injection_protection=True\n)\n</code></pre>"},{"location":"quick-start/#pattern-3-mixed-access-control","title":"Pattern 3: Mixed Access Control","text":"<pre><code>mixed_schema = SecuritySchema(\n    tables={\n        \"users\": TableSchema(\n            columns={\n                \"id\": ColumnSchema(\n                    access=Access.READ,\n                    allowed_operations={\"SELECT\"}\n                ),\n                \"email\": ColumnSchema(\n                    access=Access.WRITE,\n                    allowed_operations={\"SELECT\", \"UPDATE\"}\n                ),\n                \"password_hash\": ColumnSchema(access=Access.DENIED),\n                \"last_login\": ColumnSchema(\n                    access=Access.WRITE,\n                    allowed_operations={\"UPDATE\"}\n                )\n            }\n        )\n    }\n)\n</code></pre>"},{"location":"quick-start/#error-handling-and-logging","title":"Error Handling and Logging","text":"<p>LangSec provides detailed error reporting and optional logging:</p> <pre><code>from langsec.exceptions.errors import (\n    TableAccessError,\n    ColumnAccessError,\n    JoinViolationError,\n    QueryComplexityError\n)\n\n# Setup with logging\nconfig = LangSecConfig(\n    log_queries=True,\n    log_path=\"/var/log/langsec/queries.log\",\n    raise_on_violation=True\n)\n\nguard = SQLSecurityGuard(schema=schema, config=config)\n\ntry:\n    guard.validate_query(query)\nexcept TableAccessError as e:\n    print(f\"Invalid table access: {e}\")\nexcept ColumnAccessError as e:\n    print(f\"Invalid column access: {e}\")\nexcept JoinViolationError as e:\n    print(f\"Join violation: {e}\")\nexcept QueryComplexityError as e:\n    print(f\"Query too complex: {e}\")\n</code></pre> <p>The logging system captures: - Query validation attempts - Validation results - Detailed error information - Timestamp and context</p>"},{"location":"quick-start/#integration-with-llms","title":"Integration with LLMs","text":"<p>Example using LangSec with OpenAI:</p> <pre><code>from openai import OpenAI\nfrom langsec import SQLSecurityGuard\n\nclient = OpenAI()\nguard = SQLSecurityGuard(schema=your_schema)\n\ndef get_safe_sql(prompt: str) -&gt; str:\n    response = client.chat.completions.create(\n        model=\"gpt-3.5-turbo\",\n        messages=[\n            {\"role\": \"system\", \"content\": \"You are a SQL query generator.\"},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n    )\n\n    query = response.choices[0].message.content\n\n    # Validate query before execution\n    try:\n        guard.validate_query(query)\n        return query\n    except Exception as e:\n        raise ValueError(f\"Generated query is not safe: {e}\")\n</code></pre>"}]}